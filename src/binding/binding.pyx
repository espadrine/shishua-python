import cython
from libc.stdint cimport uint8_t, uint64_t
from libc.stddef cimport size_t
from libc.string cimport memcpy
from secrets import randbits
from hashlib import sha256

__all__ = ['SHISHUA']

cdef extern from "shishua.h":
    struct prng_state:
        uint64_t state[16]
        uint64_t output[16]
        uint64_t counter[4]

    cdef prng_state prng_init(uint64_t seed[4])
    cdef void prng_gen(prng_state *state, uint8_t *buf, size_t size)

DEF BUFSIZE = 1 << 17

cdef class SHISHUA:
    """
    SHISHUA(seed=None)

    SHISHUA generator

    Fast strong pseudo-random number generator.

    Parameters
    ----------
    seed : {None, int, array_like[ints], str}, optional
        A seed to initialize the PRNG. If None, then fresh,
        unpredictable entropy will be pulled from the OS.
    """
    cdef prng_state rng_state
    cdef uint8_t[BUFSIZE] _buffer
    cdef uint64_t _buf_index

    def __init__(self, seed=None):
        cdef uint64_t rawseed[4]
        if seed is None:
            for i in range(4):
                rawseed[i] = randbits(64)
        elif isinstance(seed, list):
            for i in range(4):
                rawseed[i] = 0
            for i in range(len(seed)):
                rawseed[i] = abs(seed[i])
        elif isinstance(seed, str):
            sha = sha256()
            sha.update(seed.encode("utf-8"))
            h = sha.digest()
            rawseed[0] = int.from_bytes(h[ 0: 4], byteorder='little')
            rawseed[1] = int.from_bytes(h[ 4: 8], byteorder='little')
            rawseed[2] = int.from_bytes(h[ 8:12], byteorder='little')
            rawseed[3] = int.from_bytes(h[12:16], byteorder='little')
        elif isinstance(seed, int):
            rawseed[0] = abs(seed)
            rawseed[1] = rawseed[2] = rawseed[3] = 0
        else:
            raise ValueError("Invalid type for SHISHUA seed")
        self.rng_state = prng_init(rawseed)
        self._fill_buffer()

    def _fill_buffer(self):
        cdef prng_state rng_state
        memcpy(&rng_state, &self.rng_state, sizeof(prng_state))
        prng_gen(&rng_state, self._buffer, BUFSIZE)
        memcpy(&self.rng_state, &rng_state, sizeof(prng_state))
        self._buf_index = 0

    def fill(self, buffer):
        """
        fill(self, buffer)

        Fill buffer with random bytes from the underlying BitGenerator

        Parameters
        ----------
        buffer : bytearray
            Buffer that gets fully rewritten with random bytes.
        """
        bl = len(buffer)  # Bytes left to fill
        bf = 0            # Bytes filled
        while bl > 0:
            chunk_size = min(BUFSIZE - self._buf_index, bl)
            buffer[bf:bf+chunk_size] = self._buffer[self._buf_index:self._buf_index+chunk_size]
            self._buf_index += chunk_size
            bl -= chunk_size
            bf += chunk_size
            if self._buf_index >= BUFSIZE:
                self._fill_buffer()

    def random_raw(self, size=1):
        """
        random_raw(self, size=1)

        Return randoms as generated by the underlying BitGenerator

        Parameters
        ----------
        size : int
            Output buffer size, in bytes.

        Returns
        -------
        out : bytes
            Drawn samples.
        """
        buf = bytearray(size)
        self.fill(buf)
        return bytes(buf)
